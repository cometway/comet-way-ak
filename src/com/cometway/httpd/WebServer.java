
package com.cometway.httpd;

import com.cometway.ak.Agent;
import com.cometway.ak.RequestAgent;
import com.cometway.ak.ServiceManager;
import com.cometway.io.FileLoggerAgent;
import com.cometway.props.Props;
import com.cometway.props.PropsList;
import com.cometway.props.PropsListServiceManager;
import com.cometway.util.ThreadPool;
import com.cometway.util.StringTools;
import com.cometway.util.Pair;
import com.cometway.util.jGrep;
import java.util.Vector;
import java.util.List;
import java.util.Hashtable;
import java.util.Date;
import java.util.Enumeration;
import java.net.InetAddress;
import javax.net.ServerSocketFactory;
import java.net.ServerSocket;
import java.net.Socket;
import java.io.IOException;
import java.text.SimpleDateFormat;


/**
* Routes HTTP requests from a server socket.
*/

public class WebServer extends Agent implements Runnable
{
	/* Use these to get return Strings for HTTP/1.1 error codes from RFC 2616 */
	/** The server responds to a partial request and accepts the partial request, telling the client to continue with its request body.*/
	public static final int CONTINUE = 100;

	/** The server has fulfilled the request but does not need to return an entity-body, and might want to return updated metainformation. The response MAY include new or updated metainformation in the form of entity-headers, which if present SHOULD be associated with the requested variant. */
	public static final int NO_CONTENT = 204;

	/**  The server has fulfilled the request and the user agent SHOULD reset the document view which caused the request to be sent. This response is primarily intended to allow input for actions to take place via user input, followed by a clearing of the form in which the input is given so that the user can easily initiate another input action. The response MUST NOT include an entity. */
	public static final int RESET_CONTENT = 205;


	/** The requested resource has been assigned a new permanent URI and any future references to this resource SHOULD use one of the returned URIs. Clients with link editing capabilities ought to automatically re-link references to the Request-URI to one or more of the new references returned by the server, where possible. This response is cacheable unless indicated otherwise. */
	public static final int MOVED_PERMANENTLY = 301;

	/**  The requested resource resides temporarily under a different URI. Since the redirection might be altered on occasion, the client SHOULD continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires header field.*/
	public static final int MOVED = 302;

	/**  The response to the request can be found under a different URI and SHOULD be retrieved using a GET method on that resource. This method exists primarily to allow the output of a POST-activated script to redirect the user agent to a selected resource. The new URI is not a substitute reference for the originally requested resource. The 303 response MUST NOT be cached, but the response to the second (redirected) request might be cacheable.*/
	public static final int USE_GET = 303;

	/**  If the client has performed a conditional GET request and access is allowed, but the document has not been modified, the server SHOULD respond with this status code. The 304 response MUST NOT contain a message-body, and thus is always terminated by the first empty line after the header fields. */
	public static final int NOT_MODIFIED = 304;

	/**  The requested resource MUST be accessed through the proxy given by the Location field. The Location field gives the URI of the proxy. The recipient is expected to repeat this single request via the proxy. 305 responses MUST only be generated by origin servers. */
	public static final int USE_PROXY = 305;

	/**  The requested resource resides temporarily under a different URI. Since the redirection MAY be altered on occasion, the client SHOULD continue to use the Request-URI for future requests. This response is only cacheable if indicated by a Cache-Control or Expires header field.*/
	public static final int TEMPORARY_REDIRECT = 307;

	/**  The request could not be understood by the server due to malformed syntax. The client SHOULD NOT repeat the request without modifications. */
	public static final int BAD_REQUEST = 400;

	/**  The request requires user authentication. The response MUST include a WWW-Authenticate header field containing a challenge applicable to the requested resource. The client MAY repeat the request with a suitable Authorization header field. If the request already included Authorization credentials, then the 401 response indicates that authorization has been refused for those credentials. If the 401 response contains the same challenge as the prior response, and the user agent has already attempted authentication at least once, then the user SHOULD be presented the entity that was given in the response, since that entity might include relevant diagnostic information. */
	public static final int UNAUTHORIZED = 401;

	/**  The server understood the request, but is refusing to fulfill it. Authorization will not help and the request SHOULD NOT be repeated. If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity. If the server does not wish to make this information available to the client, the status code 404 (Not Found) can be used instead.*/
	public static final int FORBIDDEN = 403;

	/** The server has not found anything matching the Request-URI. No indication is given of whether the condition is temporary or permanent. The 410 (Gone) status code SHOULD be used if the server knows, through some internally configurable mechanism, that an old resource is permanently unavailable and has no forwarding address. This status code is commonly used when the server does not wish to reveal exactly why the request has been refused, or when no other response is applicable. */
	public static final int URL_NOT_FOUND = 404;

	/**  The method specified in the Request-Line is not allowed for the resource identified by the Request-URI. The response MUST include an Allow header containing a list of valid methods for the requested resource.*/
	public static final int METHOD_NOT_ALLOWED = 405;

	/**  The resource identified by the request is only capable of generating response entities which have content characteristics not acceptable according to the accept headers sent in the request.

	Unless it was a HEAD request, the response SHOULD include an entity containing a list of available entity characteristics and location(s) from which the user or user agent can choose the one most appropriate. The entity format is specified by the media type given in the Content-Type header field. Depending upon the format and the capabilities of the user agent, selection of the most appropriate choice MAY be performed automatically. However, this specification does not define any standard for such automatic selection. */
	public static final int ACCEPT_NOT_ALLOWED = 406;

	/**  This code is similar to 401 (Unauthorized), but indicates that the client must first authenticate itself with the proxy. The proxy MUST return a Proxy-Authenticate header field containing a challenge applicable to the proxy for the requested resource. The client MAY repeat the request with a suitable Proxy-Authorization header field*/
	public static final int PROXY_AUTHENTICATION_REQUIRED = 407;

	/**  The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time. */
	public static final int REQUEST_TIMED_OUT = 408;

	/**  The request could not be completed due to a conflict with the current state of the resource. This code is only allowed in situations where it is expected that the user might be able to resolve the conflict and resubmit the request. The response body SHOULD include enough information for the user to recognize the source of the conflict. Ideally, the response entity would include enough information for the user or user agent to fix the problem; however, that might not be possible and is not required. */
	public static final int REQUEST_CONFLICT = 409;

	/**  The requested resource is no longer available at the server and no forwarding address is known. This condition is expected to be considered permanent. Clients with link editing capabilities SHOULD delete references to the Request-URI after user approval. If the server does not know, or has no facility to determine, whether or not the condition is permanent, the status code 404 (Not Found) SHOULD be used instead. This response is cacheable unless indicated otherwise.

	The 410 response is primarily intended to assist the task of web maintenance by notifying the recipient that the resource is intentionally unavailable and that the server owners desire that remote links to that resource be removed. Such an event is common for limited-time, promotional services and for resources belonging to individuals no longer working at the server's site. It is not necessary to mark all permanently unavailable resources as "gone" or to keep the mark for any length of time -- that is left to the discretion of the server owner. */
	public static final int GONE = 410;

	/**  The server refuses to accept the request without a defined Content- Length. The client MAY repeat the request if it adds a valid Content-Length header field containing the length of the message-body in the request message.*/
	public static final int LENGTH_REQUIRED = 411;

	/**  The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server. This response code allows the client to place preconditions on the current resource metainformation (header field data) and thus prevent the requested method from being applied to a resource other than the one intended.*/
	public static final int PRECONDITION_FAILED = 412;

	/**  The server is refusing to process a request because the request entity is larger than the server is willing or able to process. The server MAY close the connection to prevent the client from continuing the request.*/
	public static final int REQUEST_ENTITY_TOO_LARGE = 413;

	/**  The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret. This rare condition is only likely to occur when a client has improperly converted a POST request to a GET request with long query information, when the client has descended into a URI "black hole" of redirection (e.g., a redirected URI prefix that points to a suffix of itself), or when the server is under attack by a client attempting to exploit security holes present in some servers using fixed-length buffers for reading or manipulating the Request-URI.*/
	public static final int REQUEST_URI_TOO_LONG = 414;

	/**  The server is refusing to service the request because the entity of the request is in a format not supported by the requested resource for the requested method.*/
	public static final int UNSUPPORTED_MEDIA_TYPE = 415;

	/**  A server SHOULD return a response with this status code if a request included a Range request-header field, and none of the range-specifier values in this field overlap the current extent of the selected resource, and the request did not include an If-Range request-header field. (For byte-ranges, this means that the first- byte-pos of all of the byte-range-spec values were greater than the current length of the selected resource.)*/
	public static final int CANNOT_SATISFY_REQUEST_RANGE = 416;

	/**  The expectation given in an Expect request-header field could not be met by this server, or, if the server is a proxy, the server has unambiguous evidence that the request could not be met by the next-hop server.*/
	public static final int EXPECTATION_FAILED = 417;

	/**  The server encountered an unexpected condition which prevented it from fulfilling the request.*/
	public static final int SERVER_ERROR = 500;

	/**  The server does not support the functionality required to fulfill the request. This is the appropriate response when the server does not recognize the request method and is not capable of supporting it for any resource.*/
	public static final int NOT_IMPLEMENTED = 501;

	/**  The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request. */
	public static final int BAD_GATEWAY = 502;

	/**  The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication is that this is a temporary condition which will be alleviated after some delay. If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given, the client SHOULD handle the response as it would for a 500 response.*/
	public static final int SERVICE_UNAVAILABLE = 503;

	/**  The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the URI (e.g. HTTP, FTP, LDAP) or some other auxiliary server (e.g. DNS) it needed to access in attempting to complete the request.*/
	public static final int GATEWAY_TIMEOUT = 504;

	/**  The server does not support, or refuses to support, the HTTP protocol version that was used in the request message. The server is indicating that it is unable or unwilling to complete the request using the same major version as the client, as described in section 3.1, other than with this error message. The response SHOULD contain an entity describing why that version is not supported and what other protocols are supported by that server.*/
	public static final int VERSION_NOT_SUPPORTED = 505;


	public static final String VERSION_STR = "Comet Way Web Server 3.0 04-24-2008";
	protected static Props mimeTypes;
	protected boolean multihome;

	/* Standard Date Formats used in HTTP */
	public static final SimpleDateFormat dateFormat_RFC822 = new SimpleDateFormat("EEE, dd MMM yyyy HH:mm:ss zzz");
	public static final SimpleDateFormat dateFormat_RFC850 = new SimpleDateFormat("EEEEEEEEE, dd-MMM-yy HH:mm:ss zzz");
	public static final SimpleDateFormat dateFormat_ANSI = new SimpleDateFormat("EEE MMM dd HH:mm:ss yyyy");


	// protected int maxConnections;

	protected int numConnections;
	protected ThreadPool threadPool;
	protected Thread runThread;
	protected RequestAgent logger;


	// used for debugging at the moment
	public int counter=0;

	// used for default HTML responses
	public static HTMLResponseInterface responseAgent;


	// Webserver Extensions
	protected Hashtable extensions;
	protected Vector undefinedDomains;


	/**
	* Initializes this agent's properties by providing default
	* values fo each of the following missing properties:
	* 'bind_address' (default: all),
	* 'bind_port' (default: 80)
	* 'log_requests' (default: true)
	* 'max_connections' (default: 200)
	* 'serversocket_queue_size' (default: 50)
	* 'mime_types_file' (default: mime_types)
	* 'multihome' (default: false)
	* 'strict_http_version' (default:false)
	* 'thread_pool_timeout' (default: 0)
	* 'use_inet_address_methods' (default: true)
	* 'socket_timeout' (default:30000)
	* 'socket_initial_timeout' (default:3000)
	* 'max_uri_length' (default:512)
	* 'max_field_length' (default:128)
	* 'html_response_agent' (default:none)
	* 'cache_extensions' (default:true)
	* 'max_cached_extensions' (default:20)
	* 'service_name' (default:WebServer-'bind_port')
	*/

	public void initProps()
	{
		setDefault("bind_address", "all");
		setDefault("bind_port", "80");
		setDefault("log_requests", "true");
		setDefault("logger_agent_name","logger_agent");
		setDefault("max_connections", "200");
		setDefault("serversocket_queue_size","50");
		setDefault("mime_types_file", "mime_types");
		setDefault("multihome", "false");
		setDefault("strict_http_version","false");
		setDefault("thread_pool_timeout", "0");
		setDefault("use_inet_address_methods", "true");
		setDefault("socket_timeout","30000");
		setDefault("socket_initial_timeout","3000");
		setDefault("max_uri_length","4096");
		setDefault("max_field_length","2048");
		setDefault("max_multipart_length","10240000");
		setDefault("html_response_agent","none");
		setDefault("cache_extensions","true");
		setDefault("max_cached_extensions","20");

		setDefault("service_name","WebServer-"+getString("bind_port"));
	}


	/**
	* Starts helper agents and threads.
	*/

	public void start()
	{
		try
		{
			threadPool = new ThreadPool(getInteger("max_connections"));
			runThread = new Thread(this, "HTTPDAgent");

			runThread.setPriority(Thread.NORM_PRIORITY);
			runThread.start();
		}
		catch (Exception e)
		{
			error("Error initializing Thread Pool", e);
		}

		multihome = getBoolean("multihome");

		extensions = new Hashtable();
		undefinedDomains = new Vector();

		try
		{
			loadMimeTypes(getString("mime_types_file"));
		}
		catch (Exception e)
		{
			loadDefaultMimeTypes();
		}

		if (getBoolean("log_requests"))
		{
			logger = (RequestAgent) getServiceImpl(getString("logger_agent_name"));

			println("Logging requests to: " + logger);
		}

		if(getString("html_response_agent").equals("none")) {
			responseAgent = null;
		}
		else {
			try {
				responseAgent = (HTMLResponseInterface)ServiceManager.getService(getString("html_response_agent"));
			}
			catch(ClassCastException cce) {
				error("Could not use '"+getString("html_response_agent")+"' agent for HTML responses, using default");
				responseAgent = null;
			}
		}

		register();
	}


	/**
	* Right now you can't stop this agent because the threadPool threads
	* can't be cleaned up absolutely.
	*/

	public void stop()
	{
	}


	/**
	 * This creates the ServerSocket. Classes that extend WebServer can override this
	 * method in order to create different ServerSockets.
	 */
	protected ServerSocket getServerSocket(String bind_address, int port) throws IOException
	{
		ServerSocket ssock = null;
		ServerSocketFactory ssf = ServerSocketFactory.getDefault();
		if (bind_address.equals("all")) {
			ssock = ssf.createServerSocket(port,getInteger("serversocket_queue_size"));
		}
		else {
			InetAddress address = InetAddress.getByName(bind_address);
			ssock = ssf.createServerSocket(port, getInteger("serversocket_queue_size"), address);
		}
		return(ssock);
	}


	/**
	 * This accepts (or denies) an incoming connecting through the given ServerSocket.
	 * This method MUST block until a valid connected Socket is returned.
	 */
	protected Socket acceptConnection(ServerSocket ssock) throws IOException
	{
		return(ssock.accept());
	}


	/**
	* Starts WebServer, attempts to bind port.
	*/
	public void run()
	{
		String bind_address = getTrimmedString("bind_address");
		int port = getInteger("bind_port");
		int thread_pool_timeout = getInteger("thread_pool_timeout");
		ServerSocket ssock = null;

		try
		{
			println(VERSION_STR);
			println("Starting WebServer and listening to " + bind_address + " on port " + port + "...");

			ssock = getServerSocket(bind_address,port);

			println("Server bound successfully.");

			while (true)
			{
				Socket socket = null;

				try
				{
					if(thread_pool_timeout<=0) {
						if(threadPool.totalThreads() >= getInteger("max_connections")) {
							while(threadPool.freeThreads()==0) {
								try {
									Thread.sleep(500);
								}
								catch(Exception e) {
									break;
								}
							}
						}
					}
					socket = acceptConnection(ssock);

					ConnectionKMethod kMethod = new ConnectionKMethod(this, socket);

					if(thread_pool_timeout>0) {
						threadPool.getThreadOrWait(kMethod, thread_pool_timeout);
					}
					else {
						while(!threadPool.getThread(kMethod)) {
							Thread.sleep(getInteger("socket_initial_timeout"));
						}
					}
				}
				catch (Exception e)
				{
					if (socket != null)
					{
						try
						{
							socket.close();
						}
						catch (Exception er)
						{
							// do nothing here
						}
					}

					error("Error in main loop", e);
					printThreads();
				}
			}
		}
		catch (Exception e)
		{
			error("Error binding server socket (port " + port + ")", e);
		}
	}

	// Moved this from the ConnectionKMethod
	/**
	 * Retrieve an Agent that will handle an HTTPAgentRequest
	 */
	public RequestAgent getRequestAgent(String host, String serviceName)
	{
		RequestAgent agent = null;
		String prefix = "http://";
		int bind_port = getInteger("bind_port");
		if(bind_port==443) {
			prefix="https://";
		}
		agent = (RequestAgent)getServiceImpl(prefix+host+serviceName);
		if(agent==null) {
			agent = (RequestAgent)getServiceImpl(prefix+host+":"+bind_port+serviceName);
			if(agent==null) {
				agent = (RequestAgent)getServiceImpl(host+":"+bind_port+serviceName);
				if(agent==null) {
					agent = (RequestAgent)getServiceImpl(host+serviceName);
					if(agent==null) {
						agent = (RequestAgent)getServiceImpl(serviceName);
						if(agent==null) {
							agent = (RequestAgent)getServiceImpl(serviceName.substring(1));
						}
					}
				}
			}
		}

		return(agent);
	}



	/**
	 * This is the temporary way of adding extensions. The domain can either be a domain name
	 * that uses this extension (without the http://), 'all' for extensions that affect all
	 * domains, or 'default' for extensions when not multihoming or when a domain name wasn't
	 * given. The priority is a number, preferably less then 10000, that determines the order
	 * of which extensions get run, extensions that share the same number get run in some
	 * undetermined order. The service is the WebServerExtension object.
	 *
	 * The point of doing all this initial work is so the ordering, and running of extensions
	 * are made as fast as possible when they are used to handle requests.
	 */
	public void addExtension(String domain, String priority, WebServerExtension service)
	{
		Vector allExtensions = new Vector();
		if(extensions.containsKey("all")) {
			allExtensions = (Vector)extensions.get("all");
		}
		else {
			extensions.put("all",allExtensions);
		}

		Pair p = new Pair(priority,service);
		synchronized(extensions) {  		// This is just being paranoid
			if(domain.equals("all")) {
				if(!hasExtension(allExtensions,service)) {
					allExtensions.addElement(p);
					allExtensions = StringTools.pairSort(allExtensions);
					extensions.put(domain,allExtensions);
					println("Extension: '"+service+"' added for domain: "+domain);
				
					Enumeration en = extensions.keys();
					while(en.hasMoreElements()) {
						String domainString = (String)en.nextElement();
						if(!domainString.equals("all")) {
							Vector domainExtensions = (Vector)extensions.get(domainString);
							if(!hasExtension(domainExtensions,service)) {
								domainExtensions.addElement(p);
								domainExtensions = StringTools.pairSort(domainExtensions);
								extensions.put(domainString,domainExtensions);
							}
							else {
								warning("An extension '"+service+"' has already been added to the '"+domainString+"' domain. Second instance ignored.");
							}
						}
					}
				}
				else {
					warning("An extension '"+service+"' has already been added to the 'all' domain. Second instance ignored.");
				}
			}
			else {
				Vector domainVector = new Vector();
				if(!extensions.containsKey(domain)) {
					extensions.put(domain,domainVector);
					for(int x=0;x<allExtensions.size();x++) {
						domainVector.addElement(allExtensions.elementAt(x));
					}
				}
				else {
					domainVector = (Vector)extensions.get(domain);
				}
				if(!hasExtension(domainVector,service)) {
					domainVector.addElement(p);
					domainVector = StringTools.pairSort(domainVector);
					extensions.put(domain,domainVector);
					println("Extension: '"+service+"' added for domain: "+domain);
				}
				else {
					warning("An extension '"+service+"' has already been added to the '"+domain+"' domain. Second instance ignored.");
				}
			}
		}
	}

	/**
	 * This is used by the ConnectionKMethod to get a WebServerExtension.
	 */
	public Vector getExtensions(String domain)
	{
		Vector rval = null;

		if(ServiceManager.getServiceManager() instanceof PropsListServiceManager.PropsListServiceManagerImpl) {
			if(getBoolean("cache_extensions")) {
				if(extensions.containsKey(domain)) {
					rval = new Vector();
					Vector domainExtensions = (Vector)extensions.get(domain);
					for(int x=0;x<domainExtensions.size();x++) {
						try {
							rval.addElement(((Pair)domainExtensions.elementAt(x)).second());
						}
						catch(Exception e) {
							error("Error getting extension for domain: "+domain,e);
						}
					}
				}
			}
			if(rval==null) {
				String prefix = "extension://";
				List list = ServiceManager.getServiceManager().listServices(prefix+domain+":"+getString("bind_port"),null);
				Vector v = new Vector();
				for(int x=0;x<list.size();x++) {
					// The assumption here is the list is ALWAYS sorted
					v.addElement(new Pair(((Props)list.get(x)).getString("agent_id"),list.get(x)));
					if(getBoolean("cache_extensions")) {
						try {
							WebServerExtension extension = (WebServerExtension)list.get(x);
							if(extensions.size()<getInteger("max_cached_extensions")) {
								addExtension(domain,extension.getString("agent_id"),extension);
								debug("Caching: "+extension+" under domain '"+domain+"'");
							}
						}
						catch(Exception e) {
							error("Could not cache extension: "+list.get(x),e);
						}
					}
				}
				v = StringTools.pairSort(v);
				rval = new Vector();
				for(int x=0;x<v.size();x++) {
					rval.addElement(((Pair)v.elementAt(x)).second());
				}
			}
		}
		else {
			rval = new Vector();
			if(!extensions.containsKey(domain)) {
				domain = "default";
			}
			if(extensions.containsKey(domain)) {
				Vector domainExtensions = (Vector)extensions.get(domain);
				for(int x=0;x<domainExtensions.size();x++) {
					try {
						rval.addElement(((Pair)domainExtensions.elementAt(x)).second());
					}
					catch(Exception e) {
						error("Error getting extension for domain: "+domain);
					}
				}
			}
		}

		return(rval);
	}

	/**
	 * This method clears the cache. The next attempt to get any extension will cause them
	 * to get cached (if the cache_extensions property is set to true)
	 */
	public void clearExtensionsCache()
	{
		extensions = new Hashtable();
	}



	private boolean hasExtension(Vector v, WebServerExtension extension)
	{
		boolean rval = false;
		try {
			for(int x=0;x<v.size();x++) {
				Pair p = (Pair)v.elementAt(x);
				if(p.second().equals(extension)) {
					rval = true;
					break;
				}
			}
		}
		catch(Exception e) {;}
		return(rval);
	}



	public void printThreads()
	{
		ThreadGroup top = null;
		Thread current = Thread.currentThread();
		top = current.getThreadGroup();
		while(top.getParent()!=null) {
			top = top.getParent();
		}

		System.out.println("\n\nTHREADS: #########################################################################");
		//		error("THREADS: #########################################################################");

		Thread[] threads = new Thread[10000];
		int number = top.enumerate(threads);
		for(int x = 0;x<number;x++) {
			System.out.println("thread("+threads[x].getName()+") group("+threads[x].getThreadGroup().getName()+") priority("+threads[x].getPriority()+")");
			//			error("thread("+threads[x].getName()+") group("+threads[x].getThreadGroup().getName()+") priority("+threads[x].getPriority()+")");
			System.out.println("      isAlive("+threads[x].isAlive()+") isInterrupted("+threads[x].isInterrupted()+") isDaemon("+threads[x].isDaemon()+")");
			//			error("      isAlive("+threads[x].isAlive()+") isInterrupted("+threads[x].isInterrupted()+") isDaemon("+threads[x].isDaemon()+")");
			threads[x].dumpStack();
			System.out.println("\n");
		}
	}



	/**
	 * This method uses the return codes (static final int) in this Class to return a generic response.
	 */
	public static String getHTMLByCode(int code)
	{
		return (getHTMLByCode(code, null, null));
	}

	/**
	 * This method uses the return codes (static final int) in this Class to return a generic response.
	 * If a keep-alive connection is to be maintained, use the keepAliveField parameter to indicate that
	 * the response should contain a 'Connection: Keep-Alive' field and include the parameter also as a field.
	 */
	public static String getHTMLByCode(int code, String keepAliveField)
	{
		return(getHTMLByCode(code, keepAliveField, null));
	}

	/**
	 * This method uses the return codes (static final int) in this Class to return a generic response.
	 * This method also supports the keepAliveField parameter as well as any extra headers that needs to
	 * be included in the generic response.
	 */
	public static String getHTMLByCode(int code, String keepAliveField, String extraHeaders)
	{
		try {
			return(responseAgent.getHTMLByCode(code,keepAliveField,extraHeaders));
		}
		catch(Exception e) {
			StringBuffer b = new StringBuffer();
			StringBuffer content = new StringBuffer();
			StringBuffer conn = new StringBuffer();
			
			if(extraHeaders!=null) {
				if(extraHeaders.trim().length()>0) {
					conn.append(extraHeaders);
					if(extraHeaders.charAt(extraHeaders.length()-1)!='\n') {
						conn.append('\n');
					}
				}
			}
			
			if (keepAliveField != null)
			{
				keepAliveField = keepAliveField.trim();
				
				if ((keepAliveField.length() > 0) && keepAliveField.toLowerCase().startsWith("keep-alive"))
				{
					conn.append("Connection: Keep-Alive\r\n");
					conn.append(keepAliveField);
					conn.append("\r\n\r\n");
				}
			}
			
			if (conn.length() == 0)
			{
				conn.append("Connection: close\r\n\r\n");
			}
			
			if(conn.toString().lastIndexOf("\r\n\r\n")!=conn.length()-2) {
				conn.append("\r\n");
			}
			
			if(code == CONTINUE) {
				// The 100 CONTINUE response has no other headers.
				b.append("HTTP/1.1 100 Continue.\r\n\r\n");
				//				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				//				b.append(conn);
			}
			else if(code == NO_CONTENT) {
				b.append("HTTP/1.1 204 No Content.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				b.append(conn);
			}
			else if(code == RESET_CONTENT) {
				b.append("HTTP/1.1 205 Reset Content.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				b.append(conn);
			}
			else if(code == MOVED_PERMANENTLY) {
				b.append("HTTP/1.1 301 Moved Permanently.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>301 Moved Permanently</TITLE></HEAD>\n");
				content.append("<BODY><H1>301 Moved Permanently</H1></BODY>\n");
				content.append("The requested URL has been permanently moved to another location.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}			
			else if(code == MOVED) {
				b.append("HTTP/1.1 302 Moved.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>302 Moved</TITLE></HEAD>\n");
				content.append("<BODY><H1>302 Moved</H1></BODY>\n");
				content.append("The requested URL has been moved to another location.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}			
			else if(code == USE_GET) {
				b.append("HTTP/1.1 303 See Other.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>303 See Other</TITLE></HEAD>\n");
				content.append("<BODY><H1>303 See Other</H1></BODY>\n");
				content.append("The requested URL has been moved to another location and a GET request must be used to retrieve it.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}			
			else if(code == NOT_MODIFIED) {
				b.append("HTTP/1.1 304 Not Modified.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				b.append(conn);
			}
			else if(code == USE_PROXY) {
				b.append("HTTP/1.1 305 Use Proxy.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>305 Use Proxy</TITLE></HEAD>\n");
				content.append("<BODY><H1>305 Use Proxy</H1></BODY>\n");
				content.append("The requested URL requires the use of the given proxy.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if(code == TEMPORARY_REDIRECT) {
				b.append("HTTP/1.1 307 .\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>307 Temporary Redirect</TITLE></HEAD>\n");
				content.append("<BODY><H1>307 Temporary Redirect</H1></BODY>\n");
				content.append("The requested URL has been temporarily moved to another location\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}			
			else if (code == BAD_REQUEST)
			{
				b.append("HTTP/1.1 400 Bad Request.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>400 BAD Request</TITLE></HEAD>\n");
				content.append("<BODY><H1>400 Bad Request</H1></BODY>\n");
				content.append("The server could not understand your request.\n");
				content.append("If this problem persists contact the administrator.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == UNAUTHORIZED)
			{
				b.append("HTTP/1.1 401 Unauthorized.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>401 Unauthorized</TITLE></HEAD>\n");
				content.append("<BODY><H1>401 Unauthorized</H1>\n");
				content.append("You are not authorized to access this url.");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == FORBIDDEN)
			{
				b.append("HTTP/1.1 403 Forbidden.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>403 Forbidden</TITLE></HEAD>\n");
				content.append("<BODY><H1>403 Forbidden</H1>\n");
				content.append("The administrator has deemed this area of the server forbidden.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == URL_NOT_FOUND)
			{
				b.append("HTTP/1.1 404 URL not found.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>404 URL not found</TITLE></HEAD>\n");
				content.append("<BODY><H1>404 URL not found</H1>\n");
				content.append("The URL was not found on the server. \n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == METHOD_NOT_ALLOWED)
			{
				b.append("HTTP/1.1 405 Method Not Allowed\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>405 Method Not Allowed</TITLE></HEAD>\n");
				content.append("<BODY><H1>405 Method Not Allowed</H1>\n");
				content.append("The requested method is not allowed.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == ACCEPT_NOT_ALLOWED)
			{
				b.append("HTTP/1.1 406 Accept Not Allowed\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>406 Accept Not Allowed</TITLE></HEAD>\n");
				content.append("<BODY><H1>406 Accept Not Allowed</H1>\n");
				content.append("One or more of the accept content characteristics is not allowed.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == PROXY_AUTHENTICATION_REQUIRED)
			{
				b.append("HTTP/1.1 407 Proxy Authentication Required\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>407 Proxy Authentication Required</TITLE></HEAD>\n");
				content.append("<BODY><H1>407 Proxy Authentication Required</H1>\n");
				content.append("You must first authenticate with your proxy server first.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == REQUEST_TIMED_OUT)
			{
				b.append("HTTP/1.1 408 Request Timed Out.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>408 Request Timed Out</TITLE></HEAD>\n");
				content.append("<BODY><H1>408 Request Timed Out.</H1>\n");
				content.append("The webserver did not receive a valid request within the time the server was prepared to wait. Try resending the request.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == REQUEST_CONFLICT)
			{
				b.append("HTTP/1.1 409 Conflict.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>409 Request Conflict</TITLE></HEAD>\n");
				content.append("<BODY><H1>409 Request Conflict.</H1>\n");
				content.append("The request could not be completed due to a conflict with the current state of the resource.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == GONE)
			{
				b.append("HTTP/1.1 410 Gone.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>410 Resource No Longer Available</TITLE></HEAD>\n");
				content.append("<BODY><H1>410 Resource No Longer Available.</H1>\n");
				content.append("The requested resource is no longer available at the server and no forwarding address is known. This condition is expected to be considered permanent.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == LENGTH_REQUIRED)
			{
				b.append("HTTP/1.1 411 Length Required.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>411 Length Required</TITLE></HEAD>\n");
				content.append("<BODY><H1>411 Length Required.</H1>\n");
				content.append("The request did not contain a Length field, which is required.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == PRECONDITION_FAILED)
			{
				b.append("HTTP/1.1 412 Precondition Failed.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>412 Precondition Failed</TITLE></HEAD>\n");
				content.append("<BODY><H1>412 Precondition Failed.</H1>\n");
				content.append("The precondition given in one or more of the request-header fields evaluated to false when it was tested on the server.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == REQUEST_ENTITY_TOO_LARGE)
			{
				b.append("HTTP/1.1 413 Request Entity Too Large.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>413 Request Entity Too Large</TITLE></HEAD>\n");
				content.append("<BODY><H1>413 Request Entity Too Large.</H1>\n");
				content.append("The server is refusing to process a request because the request entity is larger than the server is willing or able to process.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == REQUEST_URI_TOO_LONG)
			{
				b.append("HTTP/1.1 414 Request URI Too Long.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>414 Request URI Too Long</TITLE></HEAD>\n");
				content.append("<BODY><H1>414 Request URI Too Long.</H1>\n");
				content.append("The server is refusing to service the request because the Request-URI is longer than the server is willing to interpret.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == UNSUPPORTED_MEDIA_TYPE)
			{
				b.append("HTTP/1.1 415 Unsupported Media Type.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>415 Unsupported Media Type</TITLE></HEAD>\n");
				content.append("<BODY><H1>415 Unsupported Media Type.</H1>\n");
				content.append("The media type given in the request is not supported.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == CANNOT_SATISFY_REQUEST_RANGE)
			{
				b.append("HTTP/1.1 416 Cannot Satisfy Request Range.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>416 Cannot Satisfy Request Range</TITLE></HEAD>\n");
				content.append("<BODY><H1>416 Cannot Satisfy Request Range.</H1>\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == EXPECTATION_FAILED)
			{
				b.append("HTTP/1.1 417 Expectation Failed.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>417 Expectation Failed</TITLE></HEAD>\n");
				content.append("<BODY><H1>417 Expectation Failed.</H1>\n");
				content.append("The expectation given in an Expect request-header field could not be met by this server.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == SERVER_ERROR)
			{
				b.append("HTTP/1.1 500 Server Error.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>500 Server Error</TITLE></HEAD>\n");
				content.append("<BODY><H1>500 Server Error.</H1>\n");
				content.append("An internal server error has occured. \n");
				content.append("Please contact the administrator about this possible problem.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == NOT_IMPLEMENTED)
			{
				b.append("HTTP/1.1 501 Not Implemented.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>501 Not Implemented</TITLE></HEAD>\n");
				content.append("<BODY><H1>501 Not Implemented.</H1>\n");
				content.append("The server does not support the functionality required to fulfill the request.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == BAD_GATEWAY)
			{
				b.append("HTTP/1.1 502 Bad Gateway.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>502 Bad Gateway</TITLE></HEAD>\n");
				content.append("<BODY><H1>502 Bad Gateway.</H1>\n");
				content.append("The server, while acting as a gateway or proxy, received an invalid response from the upstream server it accessed in attempting to fulfill the request.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == SERVICE_UNAVAILABLE)
			{
				b.append("HTTP/1.1 503 Service Unavailable.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>503 Service Unavailable</TITLE></HEAD>\n");
				content.append("<BODY><H1>503 Service Unavailable.</H1>\n");
				content.append("The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. Please try again later.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == GATEWAY_TIMEOUT)
			{
				b.append("HTTP/1.1 504 Gateway Timed Out.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>504 Gateway Timed Out</TITLE></HEAD>\n");
				content.append("<BODY><H1>504 Gateway Timed Out.</H1>\n");
				content.append("The server, while acting as a gateway or proxy, did not receive a timely response from the upstream server specified by the URI.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}
			else if (code == VERSION_NOT_SUPPORTED)
			{
				b.append("HTTP/1.1 505 Version not supported.\r\n");
				b.append("Date: "+dateFormat_RFC822.format(new Date())+"\r\n");
				content.append("<HTML>\n<HEAD><TITLE>505 Version Not Supported</TITLE></HEAD>\n");
				content.append("<BODY><H1>505 Version Not Supported</H1>\n");
				content.append("The HTTP Version (HTTP/1.0) is not supported by this server.\n");
				content.append("Please upgrade your browser to an (HTTP/1.1) compliant HTTP client.\n");
				content.append("</BODY></HTML>\n");
				b.append("Content-Length: "+content.length()+"\r\n");
				b.append(conn);
			}

			b = new StringBuffer(jGrep.grepAndReplaceText("([^\\r])\\n","$1\r\n",b.toString(),false));

			b.append(content);

			return (b.toString());
		}
	}


	public static void loadMimeTypes(String filename)
	{
		mimeTypes = Props.loadProps(filename);

		if (mimeTypes.hasProperty("html") == false)
		{
			loadDefaultMimeTypes();
		}
	}


	public static void loadDefaultMimeTypes()
	{
		mimeTypes = new Props();

		mimeTypes.setProperty("asf","video/x-ms-asf");
		mimeTypes.setProperty("asx","video/x-ms-asf");
		mimeTypes.setProperty("wma","audio/x-ms-wma");
		mimeTypes.setProperty("wax","audio/x-ms-wax");
		mimeTypes.setProperty("wmv","video/x-ms-wmv");
		mimeTypes.setProperty("wvx","video/x-ms-wvx");
		mimeTypes.setProperty("wm","video/x-ms-wm");
		mimeTypes.setProperty("wmx","video/x-ms-wmx");
		mimeTypes.setProperty("wmz","application/x-ms-wmz");
		mimeTypes.setProperty("wmd","application/x-ms-wmd");

		mimeTypes.setProperty("html", "text/html");
		mimeTypes.setProperty("htm", "text/html");
		mimeTypes.setProperty("bmp","image/x-xbitmap");
		mimeTypes.setProperty("ico","image/x-icon");
		mimeTypes.setProperty("gif", "image/gif");
		mimeTypes.setProperty("jpg", "image/jpeg");
		mimeTypes.setProperty("jpeg", "image/jpeg");
		mimeTypes.setProperty("c", "text/plain");
		mimeTypes.setProperty("java", "text/plain");
		mimeTypes.setProperty("cs", "text/plain");
		mimeTypes.setProperty("cpp", "text/plain");
		mimeTypes.setProperty("src", "text/plain");
		mimeTypes.setProperty("exe","application/octet-stream");
		mimeTypes.setProperty("com","application/octet-stream");
		mimeTypes.setProperty("gz","text/plain\nContent-Encoding: x-gzip");
		mimeTypes.setProperty("tar","application/x-tar");
		mimeTypes.setProperty("mp3","audio/x-mpeg-3");
		mimeTypes.setProperty("m3a","audio/x-mpeg-3");
		mimeTypes.setProperty("wml","text/vnd.wap.wml");
		mimeTypes.setProperty("wmlc","text/vnd.wap.wmlc");
		mimeTypes.setProperty("wmls","text/vnd.wap.wmlscript");
		mimeTypes.setProperty("wmlsc","text/vnd.wap.wmlscriptc");
		mimeTypes.setProperty("wbmp","text/vnd.wap.wbmp");
		mimeTypes.setProperty("swf","application/x-shockwave-flash");
		mimeTypes.setProperty("wmls","text/vnd.wap.wmlscript");
				
		// These are extra MIME types added for other common file types.
		mimeTypes.setProperty("pdf","application/pdf");
		mimeTypes.setProperty("doc","application/msword");
		mimeTypes.setProperty("ppt","application/vnd.ms-powerpoint");
		mimeTypes.setProperty("xls","application/vnd.ms-excel");
		mimeTypes.setProperty("aiff","audio/x-aiff");
		mimeTypes.setProperty("avi","video/x-msvideo");
		mimeTypes.setProperty("wmv","video/x-msvideo");
		mimeTypes.setProperty("hqx","application/x-mac-binhex40");
		mimeTypes.setProperty("gz","application/x-gzip");
		mimeTypes.setProperty("latex","application/x-latex");
		mimeTypes.setProperty("mid","audio/x-midi");
		mimeTypes.setProperty("midi","audio/x-midi");
		mimeTypes.setProperty("mpg", "video/mpeg");
		mimeTypes.setProperty("mpeg", "video/mpeg");
		mimeTypes.setProperty("mpe", "video/mpeg");
		mimeTypes.setProperty("m2v", "video/mpeg");
		mimeTypes.setProperty("pct","image/x-pict");
		mimeTypes.setProperty("pict","image/x-pict");
		mimeTypes.setProperty("ps","application/postscript");
		mimeTypes.setProperty("eps","application/postscript");
		mimeTypes.setProperty("qt","video/quicktime");
		mimeTypes.setProperty("moov","video/quicktime");
		mimeTypes.setProperty("mov","video/quicktime");
		mimeTypes.setProperty("ra","audio/x-pn-realaudio");
		mimeTypes.setProperty("ram","audio/x-pn-realaudio");
		mimeTypes.setProperty("rm","audio/x-pn-realaudio");
		mimeTypes.setProperty("rmp","audio/x-pn-realaudio");
		mimeTypes.setProperty("rtf","application/rtf");
		mimeTypes.setProperty("sit","application/x-stuffit");
		mimeTypes.setProperty("spc","text/x-speech");
		mimeTypes.setProperty("talk","text/x-speech");
		mimeTypes.setProperty("tif", "image/tiff");
		mimeTypes.setProperty("tiff", "image/tiff");
		mimeTypes.setProperty("au", "audio/basic");
		mimeTypes.setProperty("z","application/x-compress");
		mimeTypes.setProperty("tar","application/x-tar");
		mimeTypes.setProperty("wav", "audio/x-wav");
		mimeTypes.setProperty("tiff", "image/tiff");
		mimeTypes.setProperty("zip","application/zip");

		// Extra types
		mimeTypes.setProperty("cpt","application/mac-compactpro");
		mimeTypes.setProperty("cab","application/octet-stream");
		mimeTypes.setProperty("class","application/octet-stream");
		mimeTypes.setProperty("lha","application/octet-stream");
		mimeTypes.setProperty("lzh","application/octet-stream");
		mimeTypes.setProperty("jar","application/octet-stream");
		mimeTypes.setProperty("oda","application/oda");
		mimeTypes.setProperty("ogm","application/ogg");
		mimeTypes.setProperty("ogg","application/ogg");
		mimeTypes.setProperty("ppz","application/vnd.ms-powerpoint");
		mimeTypes.setProperty("pps","application/vnd.ms-powerpoint");
		mimeTypes.setProperty("pot","application/vnd.ms-powerpoint");
		mimeTypes.setProperty("bz2","application/x-bzip2");
		mimeTypes.setProperty("js","application/x-javascript");
		mimeTypes.setProperty("mkv","application/x-mkv");
		mimeTypes.setProperty("sh","application/x-sh");
		mimeTypes.setProperty("tcl","application/x-tcl");
		mimeTypes.setProperty("css","text/css");
		mimeTypes.setProperty("rtx","text/richtext");
		mimeTypes.setProperty("sgm","text/sgml");
		mimeTypes.setProperty("sgml","text/sgml");
		mimeTypes.setProperty("rgb","image/x-rgb");
		mimeTypes.setProperty("ppm","image/x-portable-pixmap");
		mimeTypes.setProperty("xbm","image/x-xbitmap");
		mimeTypes.setProperty("xpm","image/x-xpixmap");
		mimeTypes.setProperty("xwd","image/x-xwindowdump");
		mimeTypes.setProperty("pgm","image/x-portable-graymap");
		mimeTypes.setProperty("pbm","image/x-portable-bitmap");
		mimeTypes.setProperty("pnm","image/x-portable-anymap");
		mimeTypes.setProperty("jps","image/x-jps");
		mimeTypes.setProperty("png","image/png");
		mimeTypes.setProperty("xml","application/xml");
		mimeTypes.setProperty("dtd","application/xml");
		mimeTypes.setProperty("xsl","application/xml");
		mimeTypes.setProperty("xdm","application/x-xdma");
		mimeTypes.setProperty("xdma","application/x-xdma");
		mimeTypes.setProperty("mp4","video/mp4");
		mimeTypes.setProperty("aif","audio/x-aiff");
		mimeTypes.setProperty("aifc","audio/x-aiff");
	}



	/**
	* Determines what the mime type is based off the path,
	* returns mime type as a String in the HTTP response header.
	*/
	public static String getMimeType(String path)
	{
		String mimeType = "Content-Type: ";

		path = path.toLowerCase();

		int index = path.lastIndexOf(".");
		int slash = path.lastIndexOf("/");

		if (index > slash)
		{
			String ext = path.substring(index + 1);
			String type = mimeTypes.getString(ext);

			if (type.length() > 0)
			{
				mimeType = mimeType + type + "\r\n";
			}
			else
			{
				mimeType = mimeType + "text/html\r\n";
			}
		}
		else
		{
			mimeType = mimeType + "application/octet-stream\r\n";
		}

		return (mimeType);
	}

	/**
	 * Returns true of a mime type exists for the given path
	 */
	public static boolean hasMimeType(String path)
	{
		boolean rval = false;
		path = path.toLowerCase();

		int index = path.lastIndexOf(".");
		int slash = path.lastIndexOf("/");

		if (index > slash)
		{
			String ext = path.substring(index + 1);
			String type = mimeTypes.getString(ext);
			if(type.length()>0) {
				rval = true;
			}
		}

		return(rval);
	}
}


package com.cometway.util;

//import com.cometway.util.ExecuteCommand;
import com.cometway.ak.RequestAgent;
import com.cometway.ak.AgentRequest;

import java.util.Vector;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;


/**
 * This RequestAgent takes a set of properties passed to it via the AgentRequest and generates a 
 * Certificate and Private Key based on how the agent was set up. If the AgentRequest has an 'id'
 * property (no spaces), that id is used to identify the req, cert, and key. If the 'id' is not
 * provided, a random one will be generated. Other properties which are used to generated the certificate
 * are 'country', 'state', 'city', 'organization', 'unit', 'common' and 'email'. If they are not provided
 * then the agent's defaults are used. The agent will return the cert and key as properties in the
 * agent request as '(id)_cert' and '(id)_key', where the id is the one provided or the one automatically
 * generated. Optionally, the agent can be setup to return the cert and key through the AgentRequest's
 * OutputStream (as Strings).
 *
 * This agent utilizes the openssl command-line utility to generated requests, certificates, keys, and 
 * any key/cert conversion. This agent will not function properly without openssl installed. A keys and
 * certs directory are required, this is where the generated keys and certs will go, although you can
 * optionally have this agent remove the certs and/or keys after they've been generated and the request
 * handled. Optionally, a work and CA directory can be set. If the work directory is blank or doesn't
 * exist, the parent directory is used to store intermediate files. If the CA directory is provided but
 * doesn't exist, no CA certs or keys will be used to generate the certificate. Likewise, if the provided
 * CA cert or key is missing, CA's will not be used. If the CA serial is provided but doesn't exist, one
 * will be created. None of the files and directories can have spaces.
 *
 */
public class OpenSSLGenerateCert extends RequestAgent
{
	protected File parent;
	protected File work;
	protected File ca;
	protected File caCert;
	protected File caKey;
	protected File caSerial;
	protected File certOut;
	protected File keyOut;

	public void initProps()
	{
		setDefault("service_name","generate_certificate");
		setDefault("send_certs_to_stream","true");   // if this is set to true, the cert is sent to the AgentRequest's output stream
		setDefault("send_keys_to_stream","true");    // if this is set to true, the key is sent to the AgentRequest's output stream
		setDefault("openssl_command","openssl");     // openssl command, 'openssl' is probably good enough, you may need full path

		// the root directory for the CA, work, output, and private key directories
		setDefault("parent_directory",".");
		setDefault("work_directory","work");  // this is optional

		// If there is a root CA, put the cert and key here
		setDefault("ca_directory","ca");
		setDefault("ca_cert","");             // this needs to be in PEM format
		setDefault("ca_key","");              // this needs to be in PEM format
		setDefault("ca_serial","ca.srl");     // the serial file for this CA, if this doesn't exist openssl will create one

		// these directories are where the generated x509 certs and rsa keys are stored
		setDefault("certificate_directory","certs");
		setDefault("private_key_directory","keys");

		// if these are set to true, then the generated keys and certs will be removed from the local filesystem
		setDefault("remove_keys","false");
		setDefault("remove_certs","false");

		// These are the default values of given to the REQ openssl command, these will
		// be used if the equivalent isn't provided in the AgentRequest
		setDefault("default_days","365");
		setDefault("default_bits","1024");
		setDefault("default_country","US");                   // This is required
		setDefault("default_state","");                       // This is optional
		setDefault("default_city","");                        // This is optional
		setDefault("default_organization","");                // company's name or optionally you can put the machine's name here (*.domain.TLD for example)
		setDefault("default_unit","Generated by OpenSSL");    // unit name or optional certificate information
		setDefault("default_common","");                      // Name of the person, server, or identity
		setDefault("default_email","");                       // conditionally used, required for email cert, left blank if for a webserver
	}



	public void start()
	{
		parent = new File(getString("parent_directory"));
		if(parent.exists()) {
			work = new File(parent,getString("work_directory"));
			if(!work.exists()) {
				work = parent;
			}
			ca = new File(parent,getString("ca_directory"));
			if(ca.exists()) {
				caCert = new File(ca,getString("ca_cert"));
				caKey = new File(ca,getString("ca_key"));
				caSerial = new File(ca,getString("ca_serial"));
			}
			else {
				warning("CA directory does not exists, no CA root certificate or signing will be used: "+ca.getAbsolutePath());
			}
			
			certOut = new File(parent,getString("certificate_directory"));
			keyOut = new File(parent,getString("private_key_directory"));

			if(certOut.exists()) {
				if(keyOut.exists()) {
					super.start();
				}
				else {
					error("Private key out directory missing: "+keyOut.getAbsolutePath());
					throw(new OpenSSLGenerateCertException("Private key out directory missing: "+keyOut.getAbsolutePath()));
				}
			}
			else {
				error("Private certificate out directory missing: "+keyOut.getAbsolutePath());
				throw(new OpenSSLGenerateCertException("Private certificate out directory missing: "+keyOut.getAbsolutePath()));
			}
		}
		else {
			error("Parent directory does not exists: "+parent.getAbsolutePath());
			throw(new OpenSSLGenerateCertException("Parent directory does not exists: "+parent.getAbsolutePath()));
		}
	}

	public void handleRequest(AgentRequest request)
	{
		// Create distinguished name
		DistinguishedName name = new DistinguishedName();
		if(request.hasProperty("id")) {
			name.id = request.getString("id");
		}
		else {
			// if no ID, we use timestamp
			name.id = System.currentTimeMillis()+"";
			request.setProperty("id",name.id);
		}
		name.country = request.getString("country");
		name.state = request.getString("state");
		name.city = request.getString("city");
		name.organization = request.getString("organization");
		name.unit = request.getString("unit");
		name.common = request.getString("common");
		Object o = request.getProperty("email");
		if(o instanceof String) {
			name.email = (String)o;
		}
		else if(o instanceof Vector) {
			name.emails = (Vector)o;
		}

		name.days = request.getString("days");
		name.bits = request.getString("bits");

		File req = new File(work,name.id+".csr");
		File cert = new File(certOut,name.id+"_cert.pem");
		File key = new File(keyOut,name.id+"_key.pem");

		String exception = null;

		if(generateRequest(name,req,key)) {
			if(generateX509Certificate(name,req,cert,key)) {
				cert = convertCert(request,cert,key);
				key = convertKey(request,key);
				if(readKeys(request,cert,key)) {
					if(getBoolean("send_certs_to_stream")) {
						byte[] buffer = new byte[(int)cert.length()];
						FileInputStream fin = null;
						try {
							fin = new FileInputStream(cert);
							fin.read(buffer);
							request.println(new String(buffer));
						}
						catch(Exception e) {
							error("Could not read cert: "+e);
						}
						finally {
							try {fin.close();} catch(Exception e) {;}
						}
					}
					if(getBoolean("send_keys_to_stream")) {
						byte[] buffer = new byte[(int)key.length()];
						FileInputStream fin = null;
						try {
							fin = new FileInputStream(key);
							fin.read(buffer);
							request.println(new String(buffer));
						}
						catch(Exception e) {
							error("Could not read key: "+e);
						}
						finally {
							try {fin.close();} catch(Exception e) {;}
						}
					}
				}
				else {
					exception = "Could not access generated keys/certificates";
				}
			}
			else {
				exception = "Could not generate X509 certificate";
			}
		}
		else {
			exception = "Could not generate certificate request and key";
		}

		if(getBoolean("remove_keys")) {
			key.delete();
		}
		if(getBoolean("remove_certs")) {
			cert.delete();
		}

		req.delete();

		if(exception!=null) {
			throw(new OpenSSLGenerateCertException(exception));
		}
	}


	public boolean generateRequest(DistinguishedName name, File req, File key)
	{
		boolean rval = false;

		// First we have to construct a config file for generating the certificate request
		File config = new File(work,name.id+"_openssl.cnf");
		FileOutputStream fout = null;
		try {
			fout = new FileOutputStream(config);
			fout.write(name.toString().getBytes());
			fout.flush();
			fout.close();

			StringBuffer commandString = new StringBuffer();
			commandString.append(getString("openssl_command"));
			commandString.append(" req -newkey rsa:");
			if(name.bits==null || name.bits.trim().length()==0) {
				commandString.append(getString("default_bits"));
			}
			else {
				commandString.append(name.bits);
			}
			commandString.append(" -keyout ");
			commandString.append(key.getAbsolutePath());
			commandString.append(" -nodes -config ");
			commandString.append(config.getAbsolutePath());
			commandString.append(" -out ");
			commandString.append(req.getAbsolutePath());
			//			commandString.append("'");
			executeCommand(commandString.toString());

			if(req.exists() && key.exists()) {
				rval = true;
			}
		}
		catch(IOException ioe) {
			error("Could not write config file for generating the certificate request",ioe);
		}
		finally {
			try {fout.close();} catch(IOException ioe) {;}
		}

		try {
			config.delete();
		}
		catch(Exception e) {;}

		return(rval);
	}


	public boolean generateX509Certificate(DistinguishedName name, File req, File cert, File key)
	{
		boolean rval = false;

		StringBuffer commandString = new StringBuffer();
		commandString.append(getString("openssl_command"));
		commandString.append(" x509 -days ");
		if(name.days!=null && name.days.trim().length()>0) {
			commandString.append(name.days);
		}
		else {
			commandString.append(getString("default_days"));
		}
		commandString.append(" -req -in ");
		commandString.append(req.getAbsolutePath());
		commandString.append(" -out ");
		commandString.append(cert.getAbsolutePath());
		commandString.append(" -outform pem ");
		if(caCert!=null && caCert.exists() && caKey!=null && caKey.exists()) {
			commandString.append("-CA ");
			commandString.append(caCert.getAbsolutePath());
			commandString.append(" -CAkey ");
			commandString.append(caKey.getAbsolutePath());
			commandString.append(" -CAserial ");
			commandString.append(caSerial.getAbsolutePath());
			commandString.append(" -CAcreateserial");
		}
		else {
			commandString.append("-signkey ");
			commandString.append(key.getAbsolutePath());
			//			commandString.append("'");
		}
		executeCommand(commandString.toString());

		if(cert.exists()) {
			rval = true;
		}

		return(rval);
	}


	/**
	 * If subclasses of this agent needs the key in a different format, here is where it gets done.
	 * Make sure to remove the old key file when creating the new one. Note that the input key won't be DES encrypted.
	 */
	public File convertKey(AgentRequest request, File key)
	{
		return(key);
	}

	/**
	 * If subclasses of this agent needs the cert in a different format, here is where it gets done.
	 * The private key is also provided in case the expected container is PKCS12. Note that the input key won't be DES encrypted.
	 * Make sure to remove the old cert file when creating the new one.
	 */
	public File convertCert(AgentRequest request, File cert, File key)
	{
		return(cert);
	}


	/**
	 * This method is used to read the certificate and private key from the file system.
	 * This method can be overridden if a subclass requires special handling of the cert and keys.
	 */
	public boolean readKeys(AgentRequest request, File cert, File key)
	{
		boolean keyOK = false;
		boolean certOK = false;

		byte[] buffer = new byte[(int)key.length()];
		FileInputStream fin = null;
		try {
			fin = new FileInputStream(key);
			fin.read(buffer);
			request.setProperty(request.getString("id")+"_key",buffer);
			keyOK = true;
		}
		catch(Exception e) {
			error("Could not read key: "+e);
		}
		finally {
			try {fin.close();} catch(Exception e) {;}
		}

		buffer = new byte[(int)cert.length()];
		fin = null;
		try {
			fin = new FileInputStream(cert);
			fin.read(buffer);
			request.setProperty(request.getString("id")+"_cert",buffer);
			certOK = true;
		}
		catch(Exception e) {
			error("Could not read cert: "+e);
		}
		finally {
			try {fin.close();} catch(Exception e) {;}
		}

		return(keyOK && certOK);
	}



	// These are convenience methods for subclasses to handle key conversions using openssl

	/**
	 * Convert a PEM RSA key to an unencrypted PEM PKCS8 key
	 */
	protected boolean convertRSAtoPKCS8_PEM(File rsaKey, File pkcs8Key)
	{
		pkcs8Key.delete();
		executeCommand(getString("openssl_command")+" pkcs8 -inform PEM -in "+rsaKey.getAbsolutePath()+" -topk8 -nocrypt -outform PEM -out "+pkcs8Key.getAbsolutePath());
		return(pkcs8Key.exists());
	}

	/**
	 * Convert a PEM RSA key to an unencrypted DER PKCS8 key
	 */
 	protected boolean convertRSAtoPKCS8_DER(File rsaKey, File pkcs8Key_DER)
	{
		pkcs8Key_DER.delete();
		executeCommand(getString("openssl_command")+" pkcs8 -inform PEM -in "+rsaKey.getAbsolutePath()+" -topk8 -nocrypt -outform DER -out "+pkcs8Key_DER.getAbsolutePath());
		return(pkcs8Key_DER.exists());
	}

	/**
	 * Convert a PEM RSA key to a DER RSA key
	 */
	protected boolean convertRSAtoRSA_DER(File rsaKey, File rsaKey_DER)
	{
		rsaKey_DER.delete();
		executeCommand(getString("openssl_command")+" rsa -inform PEM -in "+rsaKey.getAbsolutePath()+" -outform DER -out "+rsaKey_DER.getAbsolutePath());
		return(rsaKey_DER.exists());
	}

	/**
	 * Convert a PEM RSA key to a NET RSA key
	 *
	 * This method is currently broken, don't use it. 
	 */
	protected boolean convertRSAtoRSA_NET(File rsaKey, File rsaKey_NET, String password)
	{
		rsaKey_NET.delete();
		executeCommand(getString("openssl_command")+" rsa -inform PEM -in "+rsaKey.getAbsolutePath()+" -outform NET -passout pass:"+password+" -out "+rsaKey_NET.getAbsolutePath());
		return(rsaKey_NET.exists());
	}

	/**
	 * Convert a PEM X509 certificate to a DER X509 certificate
	 */
	protected boolean convertX509toX509_DER(File cert, File cert_DER)
	{
		cert_DER.delete();
		executeCommand(getString("openssl_command")+" x509 -inform PEM -in "+cert.getAbsolutePath()+" -outform DER -out "+cert_DER);
		return(cert_DER.exists());
	}

	/**
	 * Convert a PEM X509 certificate to a NET X509 certificate
	 */
	protected boolean convertX509toX509_NET(File cert, File cert_NET)
	{
		cert_NET.delete();
		executeCommand(getString("openssl_command")+" x509 -inform PEM -in "+cert.getAbsolutePath()+" -outform NET -out "+cert_NET);
		return(cert_NET.exists());
	}

	/**
	 * Convert a PEM X509 certificate and PEM RSA key to a PKCS12 certificate
	 */
	protected boolean convertX509toPKCS12(File cert, File key, File pkcs12Cert, String password)
	{
		pkcs12Cert.delete();
		executeCommand(getString("openssl_command")+" pkcs12 -export -inkey "+key.getAbsolutePath()+" -in "+cert.getAbsolutePath()+" -out "+pkcs12Cert.getAbsolutePath()+" -password pass:"+password);
		return(pkcs12Cert.exists());
	}








	protected void executeCommand(String commandString)
	{
		ExecuteCommand command = new ExecuteCommand(commandString);
		command.processOut = new StringBuffer();
		command.processErr = new StringBuffer();
		command.waitForProcess = true;
		command.finishedWaitTime = 1000;
		debug("Executing command: "+commandString);
		command.execute();
		debug("stdout = "+command.processOut);
		debug("stderr = "+command.processErr);
	}







	class DistinguishedName
	{
		public String id;
		public String country;
		public String state;
		public String city;
		public String organization;
		public String unit;
		public String common;
		public String email;
		public Vector emails;

		public String days;
		public String bits;

		/**
		 * This generates a sample OpenSSL config file
		 */
		public String toString()
		{
			StringBuffer rval = new StringBuffer();

			rval.append("[req]\n");
			if(bits==null || bits.trim().length()==0) {
				rval.append("default_bits = "+getString("default_bits")+"\n");
			}
			else {
				rval.append("default_bits = "+bits+"\n");
			}
			rval.append("encrypt_key = no\n");
			rval.append("prompt = no\n");
			rval.append("distinguished_name = req_distinguished_name\n\n");

			rval.append("[req_distinguished_name]\n");
			if(country!=null && country.length()>0) {
				rval.append("C = "+country+"\n");
			}
			else if(getTrimmedString("default_country").length()>0) {
				rval.append("C = "+getString("default_country")+"\n");
			}
			if(state!=null && state.length()>0) {
				rval.append("ST = "+state+"\n");
			}
			else if(getTrimmedString("default_state").length()>0)  {
				rval.append("ST = "+getString("default_state")+"\n");
			}
			if(city!=null && city.length()>0) {
				rval.append("L = "+city+"\n");
			}
			else if(getTrimmedString("default_city").length()>0)  {
				rval.append("L = "+getString("default_city")+"\n");
			}
			if(organization!=null && organization.length()>0) {
				rval.append("O = "+organization+"\n");
			}
			else if(getTrimmedString("default_organization").length()>0)  {
				rval.append("O = "+getString("default_organization")+"\n");
			}
			if(unit!=null && unit.length()>0) {
				rval.append("OU = "+unit+"\n");
			}
			else if(getTrimmedString("default_unit").length()>0)  {
				rval.append("OU = "+getString("default_unit")+"\n");
			}
			if(common!=null && common.length()>0) {
				rval.append("CN = "+common+"\n");
			}
			else if(getTrimmedString("default_common").length()>0)  {
				rval.append("CN = "+getString("default_common")+"\n");
			}
			if(email!=null && email.length()>0) {
				rval.append("emailAddress = "+email+"\n");
			}
			else if(emails!=null) {
				for(int x=0;x<emails.size();x++) {
					rval.append(x+".emailAddress = "+emails.elementAt(x)+"\n");
				}
			}
			else if(getTrimmedString("defauly_email").length()>0)  {
				rval.append("emailAddress = "+getString("default_email")+"\n");
			}

			return(rval.toString());
		}
	}

}

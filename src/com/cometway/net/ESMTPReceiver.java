package com.cometway.net;import java.text.*;import java.util.*;import java.net.*;import java.io.*;import com.cometway.util.*;/**  * This class implements the ESMTP protocol for the server side. It will * listen to a socket and await connections that talk the ESMTP/SMTP protocol. */public class ESMTPReceiver extends Thread implements ICommandParser{   public final static String kCRLF = "\r\n";   public final static String kDefaultGreeting = "ESMTP Generic Receiver 1.0";   public final static String kCommandUnrecognized = "500 Syntax error, command unrecognized";    public final static String kSyntaxError = "501 Syntax error in parameters or arguments";    public final static String[] kBasicCommands = { "DATA", "EHLO", "HELO", "MAIL",						   "NOOP", "QUIT", "RCPT", "RSET",						   "VRFY" };   // a couple of sequential state tokens   protected final static int kMail = 2;   protected final static int kRcpt = 3;   protected final static int kRset = 5;   private static int id = 0;   private int myId = (id++);   protected Socket         socket;   protected BufferedReader in;   protected PrintWriter    out;   protected Hashtable commandHash;   protected Vector    extendedCommands;    protected String  greeting;   protected boolean seenHelo;   protected boolean seenMail;   protected boolean seenRcpt;   protected boolean honestPeer;   protected int     state;   protected static String      localHostName;   protected static InetAddress localHost;	protected        InetAddress sendingHost;   // SMTPReceiver state variables   protected String reversePath;   protected String data;   protected Vector forwardPaths;	private boolean isConnected = false;   protected boolean debug;   // a couple of local cheater classes for making /dev/null style io streams (do nothing   //  streams   class FakeWriter extends Writer   {      public void write(char[] cbuf, int off, int len) throws IOException      {	 ;      }            public void flush() throws IOException      {	 ;      }            public void close() throws IOException      {	 ;      }   }      class FakeReader extends Reader   {      public int read(char cbuf[], int off, int len) throws IOException      {	 return -1;      }            public void close() throws IOException      {	 ;      }   }   /** this constructor is for using an instance of this class only as an    *   ICommandParser.  the problem is that the parseData() method actually needs to use    *   that in and out channels.  but using this class as an ICommandParser no I/O    *   streams need exist; so we build 'cheater' readers and writers that just do    *   nothing     */   public ESMTPReceiver()   {      super();      this.seenHelo   = false;      this.seenMail   = false;            this.seenRcpt   = false;      this.honestPeer = false;      this.state      = kRset;      this.debug      = false;      try      {			this.localHost     = InetAddress.getLocalHost();			this.localHostName = this.localHost.getHostName();      }      catch (UnknownHostException e)      {			errorPrint("unable to determine local hostname: " + e);      }		this.sendingHost = null;      this.setGreeting(kDefaultGreeting);      this.initCommands();            in  = new BufferedReader(new FakeReader());      out = new PrintWriter(new FakeWriter());   }   /**    */   public ESMTPReceiver(Socket socket)    {      // XXXX overhead here with the fake readers/writers      this();      this.setName("ESMTPReceiver " + id++);      setSocket(socket);   }   /**    */   protected void initCommands()   {      commandHash      = new Hashtable();      extendedCommands = new Vector();      for (int i = 0; i < kBasicCommands.length; i++)      {			commandHash.put(kBasicCommands[i].toUpperCase(), this);      }   }   public void setSocket(Socket socket)   {		if (this.isAlive())		{			this.close();			this.interrupt();//			this.stop();		}		      this.socket = socket;      try      {			in  = new BufferedReader(new InputStreamReader(socket.getInputStream()));			out = new PrintWriter(socket.getOutputStream(), true);      }      catch (IOException e)		{			errorPrint("unable to initialize streams: " + e);      }		isConnected = true;		this.sendingHost = socket.getInetAddress();      this.setPriority(MIN_PRIORITY + 1);      this.start();   }   /**    */   public void setGreeting(String greeting)   {      this.greeting = localHostName + " " + greeting;   }   /**    */   public void setDebug(boolean debug)   {      this.debug = debug;   }      /**    */   public void addCommandParser(String command, ICommandParser parser, boolean addExtended)   {      commandHash.put(command.toUpperCase(), parser);      if (addExtended)	 extendedCommands.addElement(command.toUpperCase());   }   /**    */   public void addCommandParser(String command, ICommandParser parser)   {      addCommandParser(command, parser, true);   }   /**    */   public String parseCommand(String command)   {      String commandCode = null;      StringTokenizer commandTok = new StringTokenizer(command);      int index = command.indexOf(" ");      if (index == -1)	 index = command.length();      // the first token is the command code and is case-insensitive      commandCode = command.substring(0, index).toLowerCase();	       if (commandCode.equals("data"))			return parseData(commandTok);      else if (commandCode.equals("ehlo"))			return parseEhlo(commandTok);      else if (commandCode.equals("helo"))			return parseHelo(commandTok);      else if (commandCode.equals("mail"))			return parseMail(command);      else if (commandCode.equals("noop"))			return parseNoop(commandTok);      else if (commandCode.equals("quit"))			return parseQuit(commandTok);      else if (commandCode.equals("rcpt"))			return parseRcpt(command);      else if (commandCode.equals("rset"))			return parseRset(commandTok);      else if (commandCode.equals("vrfy"))			return parseVrfy(commandTok);      else return kCommandUnrecognized;   }   /**    */   protected void resetState()   {      reversePath = null;      data        = null;      forwardPaths  = null;            state       = kRset;      seenMail    = false;      seenRcpt    = false;   }   /**    */   protected String parseData(Enumeration command)   {      String currentToken = null;      if (command.hasMoreElements())      {	 // strip off the command code (case-insensitive)	 currentToken = ((String) command.nextElement()).toLowerCase();	 	 if (!currentToken.equals("data"))	    // perhaps this is not the best error response at this stage	    return kCommandUnrecognized;	 else if (!seenMail)	    return "503 Need MAIL command";	 else if (!seenRcpt)	    return "503 Need RCPT (Recipient)";	 	 write("354 Enter mail, end with \".\" on a line by itself");	 data = "";	 String line = read();	 while (!line.equals("."))	 {	    // the substring here is for transparency with respect to the special meaning	    //  of the '.' character (see RFC 821 Section 4.5.2)	    if (line.startsWith(".")) line = line.substring(1);	    data = data + line + "\n";	    line = read();	 }      }      else return kCommandUnrecognized;      debugPrint("DATA RECEIVED: " + data);		prepareMessage();      routeMessage();      deliverMessage();		resetState();      return "250 Message accepted for delivery";   }   /**    */   protected String parseEhlo(Enumeration command)   {      String currentToken    = null;      InetAddress remoteHost = null;      if (command.hasMoreElements())      {	 // strip off the command code (case-insensitive)	 currentToken = ((String) command.nextElement()).toLowerCase();	 	 if (!currentToken.equals("ehlo"))	    // perhaps this is not the best error response at this stage	    return kCommandUnrecognized;	 	 if (seenHelo)	    return "503 gibbon.com.cometway.com Duplicate HELO/EHLO";	 if (command.hasMoreElements())	 {	    // strip off what should be the hostname attached to the socket	    //  (case-insensitive) 	    currentToken = ((String) command.nextElement()).toLowerCase();	    remoteHost = socket.getInetAddress();	    debugPrint("REMOTEHOST: " + remoteHost);	    if (remoteHost.getHostName().toLowerCase().equals(currentToken))	       honestPeer = true;	    else honestPeer = false;	 }	 else return "501 ehlo requires domain address";      }      else return kCommandUnrecognized;      StringBuffer retString = new StringBuffer("250");      if (extendedCommands.size() >= 1)	 retString.append("-");      else retString.append(" ");      retString.append(localHostName + " Hello " + remoteHost.getHostName() + " [" +		       remoteHost.getHostAddress() + "], pleased to meet you");      int i = 0;      for (i = 0; i < extendedCommands.size() - 1; i++)	 retString.append(kCRLF + "250-" + 			  (String) extendedCommands.elementAt(i));      if (extendedCommands.size() >= 1)	 retString.append(kCRLF + "250 " + 			  (String) extendedCommands.elementAt(i));      seenHelo = true;	       return retString.toString();   }   /**    */   protected String parseHelo(Enumeration command)   {      String currentToken    = null;      InetAddress remoteHost = null;            if (command.hasMoreElements())      {	 // strip off the command code (case-insensitive)	 currentToken = ((String) command.nextElement()).toLowerCase();	 	 if (!currentToken.equals("helo"))	    // perhaps this is not the best error response at this stage	    return kCommandUnrecognized;	 if (seenHelo)	    return "503 gibbon.com.cometway.com Duplicate HELO/EHLO";	 if (command.hasMoreElements())	 {	    // strip off what should be the hostname attached to the socket	    //  (case-insensitive) 	    currentToken = ((String) command.nextElement()).toLowerCase();	    remoteHost = socket.getInetAddress();	    debugPrint("REMOTEHOST: " + remoteHost);	    if (remoteHost.getHostName().toLowerCase().equals(currentToken))	       honestPeer = true;	    else honestPeer = false;	 }	 else return "501 helo requires domain address";      }      else return kCommandUnrecognized;      seenHelo = true;      return "250 " + localHostName + " Hello " + remoteHost.getHostName() + " [" +	 remoteHost.getHostAddress() + "], pleased to meet you";   }	protected String parseNonRFCMail(Enumeration command)   {      String currentToken = null;		      if (command.hasMoreElements())      {			// strip off the command code (case-insensitive)			currentToken = ((String) command.nextElement()).toLowerCase();			if (!currentToken.equals("mail"))				return kCommandUnrecognized;   // not the best error response.  Q.			else if (seenMail)			{				// RFC 821 specifies that the receiver resets state when it sees MAIL command				resetState();				return "503 Sender already specified... reset state";   // complain about it			}						if (command.hasMoreElements())			{				// strip off the 'from:' parameter (case-insensitive)				currentToken = ((String) command.nextElement()).toLowerCase();								if (!currentToken.equals("from:"))					return kSyntaxError;								if (command.hasMoreElements())				{					// strip off the address parameter (NOT case-insensitive)					currentToken = (String) command.nextElement();										if (!checkPath(currentToken))						return "553 Requested Action not taken; mailbox syntax incorrect";				}				else return kSyntaxError;			}			else return kSyntaxError;      }      else return kCommandUnrecognized;		      seenMail = true;      state = kMail;		      reversePath = fixReversePath(currentToken);		      debugPrint("GIVEN REVERSEPATH: " + currentToken);      debugPrint("FIXED REVERSEPATH: " + reversePath);		      return "250 " + currentToken + "... Sender OK";			}   /**    */   protected String parseMail(String commandString)   {		Enumeration command = new StringTokenizer(commandString);      String currentToken = null;      if (command.hasMoreElements())      {			// strip off the command code (case-insensitive)			currentToken = ((String) command.nextElement()).toLowerCase();						if (!currentToken.equals("mail"))				return kCommandUnrecognized;   // not the best error response.  Q.			else if (seenMail)			{				// RFC 821 specifies that the receiver resets state when it sees MAIL command				resetState();				return "503 Sender already specified... reset state";   // complain about it			}						if (command.hasMoreElements())			{				// strip off the 'from:' parameter				currentToken = ((String) command.nextElement());				int index    = currentToken.indexOf(":");				// begin by stripping off everything up to and including ":"				if ((index == -1) || !(index < (currentToken.length() - 1)))					return parseNonRFCMail(new StringTokenizer(commandString));				String segment = currentToken.substring(0, index);								if (!segment.trim().toLowerCase().equals("from"))					return parseNonRFCMail(new StringTokenizer(commandString));								currentToken = currentToken.substring(index + 1);				if (!checkPath(currentToken))					return ("553 Requested Action not taken; mailbox syntax " +							  "incorrect");			}			else return kSyntaxError;      }      else return kCommandUnrecognized;		      seenMail = true;      state = kMail;      reversePath = fixReversePath(currentToken);      debugPrint("GIVEN REVERSEPATH: " + currentToken);      debugPrint("FIXED REVERSEPATH: " + reversePath);      return "250 " + currentToken + "... Sender OK";   }   /**    */   protected static String fixReversePath(String path)   {      path = stripBrackets(path);      // RFC 821 states that IN ANY CASE the [receiver] SMTP adds its own identifier to      //  the reverse-path.      return ("<@" + localHostName + ":" + path + ">");   }   /**    */   protected String parseNoop(Enumeration command)   {      return "250 OK";   }   /**    */   protected String parseQuit(Enumeration command)   {      String currentToken = null;      if (command.hasMoreElements())      {	 // strip off the command code (case-insensitive)	 currentToken = ((String) command.nextElement()).toLowerCase();	 	 if (!currentToken.equals("quit"))	    // perhaps this is not the best error response at this stage	    return kCommandUnrecognized;      }      else return kCommandUnrecognized;            return "221 " + localHostName + " closing connection";   }   protected String parseNonRFCRcpt(Enumeration command)   {      String currentToken = null;      String toAddress    = null;		      if (command.hasMoreElements())      {			// strip off the command code (case-insensitive)			currentToken = ((String) command.nextElement()).toLowerCase();						if (!currentToken.equals("rcpt"))				// perhaps this is not the best error response at this stage				return kCommandUnrecognized;			else if (!seenMail)				return "503 Need MAIL command";						if (command.hasMoreElements())			{				// strip off the 'to:' parameter (case-insensitive)				currentToken = ((String) command.nextElement()).toLowerCase();				if (!currentToken.equals("to:"))					return kSyntaxError;								if (command.hasMoreElements())				{					// strip off the address parameter (NOT case-insensitive)					toAddress = (String) command.nextElement();										if (!checkPath(toAddress))						return "553 Requested Action not taken; mailbox syntax incorrect";										// verify that currentToken represents a syntactically valid address.  Q.					if (forwardPaths == null) forwardPaths = new Vector();										forwardPaths.addElement(fixForwardPath(toAddress));				}				else return kSyntaxError;			}			else return kSyntaxError;      }      else return kCommandUnrecognized;		      seenRcpt = true;      state = kRcpt;            debugPrint("GIVEN FORWARDPATH: " + toAddress);      debugPrint("FIXED FORWARDPATH: " + fixForwardPath(toAddress));      return "250 " + toAddress + "... Recipient OK";   }   /**    */   protected String parseRcpt(String commandString)   {		Enumeration command = new StringTokenizer(commandString);      String currentToken = null;      String toAddress    = null;      if (command.hasMoreElements())      {			// strip off the command code (case-insensitive)			currentToken = ((String) command.nextElement()).toLowerCase();						if (!currentToken.equals("rcpt"))				// perhaps this is not the best error response at this stage				return kCommandUnrecognized;			else if (!seenMail)				return "503 Need MAIL command";			if (command.hasMoreElements())			{				// strip off the 'to:' parameter (case-insensitive)				currentToken = ((String) command.nextElement());				int index    = currentToken.indexOf(":");								// begin by stripping off everything up to and including ":"				if ((index == -1) || !(index < (currentToken.length() - 1)))					return parseNonRFCRcpt(new StringTokenizer(commandString));								String segment = currentToken.substring(0, index);								if (!segment.trim().toLowerCase().equals("to"))					return parseNonRFCRcpt(new StringTokenizer(commandString));		 				toAddress = currentToken.substring(index + 1);								if (!checkPath(toAddress))					return "553 Requested Action not taken; mailbox syntax incorrect";								// verify that currentToken represents a syntactically valid address.  Q.				if (forwardPaths == null) forwardPaths = new Vector();								forwardPaths.addElement(fixForwardPath(toAddress));			}			else return kSyntaxError;      }      else return kCommandUnrecognized;		      seenRcpt = true;      state = kRcpt;            debugPrint("GIVEN FORWARDPATH: " + toAddress);      debugPrint("FIXED FORWARDPATH: " + fixForwardPath(toAddress));      return "250 " + toAddress + "... Recipient OK";   }   /** fixForwardPath: given a String representing a path, function attempts to prepare    *   it for message delivery.    */   protected static String fixForwardPath(String path)   {      path = stripBrackets(path);      // first see if a pre-mailbox route exists      int index    = path.indexOf(":");      if (index != -1)      {	 // I should make sure that route starts with '@'	 String route     = path.substring(0, index);	 String routeHead = route.substring(1);	 boolean isLocal  = false;	 int chopIndex    = index + 1;	 index = route.indexOf(",");	 	 if (index != -1)	 {	    routeHead = route.substring(1, index);	    chopIndex = index + 1;	 }	 try	 {	    InetAddress headAddress = InetAddress.getByName(routeHead);	    InetAddress myAddress   = InetAddress.getByName(localHostName);	    	    isLocal = headAddress.equals(myAddress);	    	 }	 catch (UnknownHostException e)	 {	    // assume that routeHead was a no good addressName (with respect to	    //  Internet Addresses at least)	    ;	 }	 	 if (isLocal)	    return ("<" + path.substring(chopIndex) + ">");      }      return ("<" + path + ">");   }   /**    */   public static boolean checkPath(String path)   {      // right now we only try to balance angle brackets      int braceCount = 0;      for (int i = 0; i < path.length(); i++)      {	 if (path.charAt(i) == '<')	    braceCount++;	 else if (path.charAt(i) == '>')	    braceCount--;      }      return (braceCount == 0);   }   /** stripBrackets: given a path (possibly enclosed by angle brackets),    *   method attempts to strip all enclosing brackets.  this is bad since    *   when we recreate the paths later, we will only add a single level of    *   enclosing angle brackets     */   public static String stripBrackets(String path)   {      while ((path.length() > 1) &&	     (path.charAt(0) == '<') &&	     (path.charAt(path.length() - 1) == '>'))	 path = path.substring(1, path.length() - 1);      return path;   }   /** deliverMessage(): method is gauranteed to be executed before state is cleared    *   after a data command had been successfully accepted (but not necessarily    *   responded to)    */   protected void deliverMessage()   {      // we do no actual mail delivery except for the case of routing, which is		//  handled before deliverMessage() is called   }   // XXXX add routing.  Q.  check to see if RCPT was non local (if a route precedes   //  address then route to next host in list, or if no route exists but to host is   //  not localhost, route to host.  this needs to be done for all elements of the   //  forwardPaths Vector.  just use a route() method that handles the necessary   //  routing with the forwardPath and deletes those elements from the Vector   protected void routeMessage()   {      ;   }	/** prepareMessage() should occur before routeMessage() and deliverMessage()	 */	protected void prepareMessage()	{		Date currentDate = new Date();		SimpleDateFormat formatter = new SimpleDateFormat("EEE, d MMM yyyy " +																		  "hh:mm:ss z");		formatter.setTimeZone(TimeZone.getDefault());		String dateString = formatter.format(currentDate);		String senderName = 			(sendingHost == null) ? "UNKNOWN HOST" : sendingHost.getHostName();		String receivedHeader = "Received: from " + senderName + " by " +			localHostName + " with ESMTP; " + dateString;		StringBuffer newData = new StringBuffer("");		// we need to insert a Received header in any case		newData.append(receivedHeader + "\n");		boolean loop        = true;		boolean messageBody = false;		int index           = data.indexOf("\n");		String line         = "";		while (index != -1)		{			line = data.substring(0, index + 1);			data = data.substring(index + 1);						if (messageBody)				newData.append(line);			else if (!isHeader(line) && (line.charAt(0) != ' ') &&						(line.charAt(0) != '\t'))			{				if (!messageBody && !line.trim().equals(""))					newData.append("\n");								newData.append(line);				messageBody = true;			}			else newData.append(line);						index = data.indexOf("\n");		}		newData.append(data);		data = newData.toString();		debugPrint("PREPARED DATA: " + data);	}	public boolean isHeader(String line)	{		int index = line.indexOf(":");		if (index == -1)			return false;		else		{			String headerName = line.substring(0, index);			for (int i = 0; i < headerName.length(); i++)				// XXXX this checks for spaces, but not CTL characters...				if (headerName.charAt(i) == ' ')					return false;		}		return true;	}   /**    */   protected String parseRset(Enumeration command)   {      String currentToken = null;      if (command.hasMoreElements())      {	 // strip off the command code (case-insensitive)	 currentToken = ((String) command.nextElement()).toLowerCase();	 	 if (!currentToken.equals("rset"))	    // perhaps this is not the best error response at this stage	    return kCommandUnrecognized;	 // go into the 'Reset' state, clear buffers	 resetState();      }      else return kCommandUnrecognized;      return "250 Reset state";   }   /**    */   protected String parseVrfy(Enumeration command)   {      String currentToken = null;      if (command.hasMoreElements())      {	 // strip off the command code (case-insensitive)	 currentToken = ((String) command.nextElement()).toLowerCase();	 	 if (!currentToken.equals("rset"))	    // perhaps this is not the best error response at this stage	    return kCommandUnrecognized;	 if (command.hasMoreElements())	 {	    // strip off the id code	    currentToken = ((String) command.nextElement());	    	    // we just do nothing with thee user.  subclasses should override	    return ("550 " + currentToken + "... user unknown");	 }	 else return "500 Syntax error, missing id";      }      else return kCommandUnrecognized;   }   /**    */   public void run()   {      boolean loop    = true;      String line     = null;      String response = null;      String command  = null;            ICommandParser parser = null;      // Send welcome      write("220 " + greeting);      while (loop)      {			line = read();			if (line != null)			{				debugPrint("READ: " + line);								line = line.trim();								int index = line.indexOf(" ");								if (index == -1)					index = line.length();								// the toUpperCase here is less general				command  = line.substring(0, index).toUpperCase();								parser = (ICommandParser) commandHash.get(command);								if (parser != null)					response = parser.parseCommand(line);				else response = kCommandUnrecognized;								debugPrint("RESPONSE: " + response);				write(response);								// handle exceptions here by closing?  Q.								if ((response.substring(0, 3).indexOf("221") != -1) ||					 (response.substring(0, 3).indexOf("421") != -1))				{					loop = false;					close();				}			}			else			{				// XXX try to reinit streams here?				loop = false;			}      }		this.interrupt();//		this.stop();   }	public void disconnect()	{		// Q.  writing and then closing		write("221 " + localHostName + " Service closing transmission channel");		close();				this.interrupt();//		this.stop();	}      /**    */   protected String read()   {      String retString = null;      		if (isConnected)		{			try			{				retString = in.readLine();								if (retString == null)					debugPrint("End of stream reported by readLine()");			}			catch (IOException e)			{				errorPrint("failed to read from stream: " + e);				//			retString = "";			}      			return retString;		}		else return "";   }   /**    */   protected void write(String string)   {		if (isConnected)		{			out.print(string + kCRLF);			out.flush();		}   }	protected synchronized void close()	{		// XXXX 		if (out != null)		{			out.close();			out = null;		}            try      {			if (in != null)			{				in.close();				in = null;			}			if (socket != null)			{				socket.close();				socket = null;			}      }      catch (IOException e)      {			errorPrint("troubles closing connection: " + e);			isConnected = false;      }		isConnected = false;	}   /**    */   protected void errorPrint(String line)   {      System.out.println("ESMTPReceiver error (" + myId + "): " + line);   }      /**    */   protected void debugPrint(String line)   {      if (debug)			System.out.println("ESMTPReceiver (" + myId + "): " + line);   }   public static void main(String[] argv)   {      try      {			ServerSocket ssocket = new ServerSocket(25);			Socket socket = ssocket.accept();						ESMTPReceiver recv = new ESMTPReceiver(socket);      }      catch (IOException e)		{			System.out.println("ESMTPReceiver error: " + e);      }   }}